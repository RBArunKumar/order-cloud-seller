/**
 * ControlledPromise is a function that returns a promise with additional methods for resolve, reject, restart, and
 * first. This allows more granular control over the promise resolution process. It also avoids unhandled rejections by
 * catching any errors and passing them to the onFailure callback.
 *
 * @example
 *   const promise = ControlledPromise(
 *     (result) => console.log(result),
 *     (error) => console.error(error)
 *   )
 *   promise.resolve('Success') // logs: "Success"
 *   promise.reject(new Error('Failure')) // logs: Error: Failure
 *
 * @template T The type of value that the promise will resolve with.
 * @param {(result: T) => void} [onSuccess] - A callback function that is called when the promise is successfully
 *   resolved. The resolved value is passed to this function.
 * @param {(e: Error) => void} [onFailure=(e: Error) => {}] - A callback function that is called when the promise is
 *   rejected. The Error object is passed to this function. Default is `(e: Error) => {}`
 * @returns {ControlledPromise<T>} A ControlledPromise object with the following properties:
 *
 *   - Resolve: A function that when called, will resolve the promise.
 *   - Reject: A function that when called, will reject the promise with the provided error.
 *   - Restart: A function that when called, will restart the promise. This creates a new promise and replaces the current
 *       promise with the new one.
 *   - First: The first promise that was created by the restart function. This property is initially undefined, and is set
 *       when the restart function is called for the first time.
 */
export function ControlledPromise(onSuccess, onFailure = (e) => { }) {
    var first;
    const restart = () => {
        var resolve;
        var reject;
        const promise = new Promise((success, failure) => {
            resolve = (value) => {
                onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(value);
                success(value);
            };
            reject = failure;
        });
        var controlled = Object.assign(promise, {
            resolve,
            reject,
            restart,
            first
        });
        first = controlled;
        // Avoid unhandled rejection
        controlled.catch(onFailure);
        return controlled;
    };
    return restart();
}
//# sourceMappingURL=promise.js.map