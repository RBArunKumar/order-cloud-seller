export const parseLimit = (qualifier) => {
    var _a;
    const limit = parseInt((_a = qualifier === null || qualifier === void 0 ? void 0 : qualifier.match(/\[0:(\d+)\]/)) === null || _a === void 0 ? void 0 : _a[1], 10);
    if (!isNaN(limit) && limit > 0)
        return String(limit);
    return null;
};
export const parseRange = (qualifier) => {
    var _a;
    const bits = (_a = qualifier === null || qualifier === void 0 ? void 0 : qualifier.match(/\[([^\]]+)\]/)) === null || _a === void 0 ? void 0 : _a[1].split(/\s*,\s*/g).filter(Boolean).map((bit) => {
        // individual indexes
        if (bit.match(/^-?\d+$/))
            return bit;
        // ranges
        const range = bit.match(/^(\d+):(\d+)$/);
        return range && parseInt(range[1], 10) < parseInt(range[2], 10) ? range[1] + '-' + range[2] : null;
    });
    if (!(bits === null || bits === void 0 ? void 0 : bits.every(Boolean)))
        return null;
    return bits.join(',');
};
export const getQualifier = (jsonpath) => { var _a; return (_a = jsonpath === null || jsonpath === void 0 ? void 0 : jsonpath.match(/(\.\*|\[[^\]]+\])$/)) === null || _a === void 0 ? void 0 : _a[0]; };
export function cleanCollectionBit(path) {
    return path.replace(/(\[[^\]\[]+\]|\.\*)$/g, '');
}
export function normalizeCollectionScope(path) {
    return cleanCollectionBit(path) + '.*';
}
//# sourceMappingURL=datapath.js.map